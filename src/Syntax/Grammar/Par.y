-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Syntax.Grammar.Par
  ( happyError
  , myLexer
  , pExp
  ) where

import Prelude

import qualified Syntax.Grammar.Abs
import Syntax.Grammar.Lex

}

%name pExp Exp
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '%'      { PT _ (TS _ 1)    }
  '('      { PT _ (TS _ 2)    }
  ')'      { PT _ (TS _ 3)    }
  '*'      { PT _ (TS _ 4)    }
  '+'      { PT _ (TS _ 5)    }
  ','      { PT _ (TS _ 6)    }
  '-'      { PT _ (TS _ 7)    }
  '/'      { PT _ (TS _ 8)    }
  '<'      { PT _ (TS _ 9)    }
  '>'      { PT _ (TS _ 10)   }
  '^'      { PT _ (TS _ 11)   }
  'else'   { PT _ (TS _ 12)   }
  'false'  { PT _ (TS _ 13)   }
  'if'     { PT _ (TS _ 14)   }
  'rand'   { PT _ (TS _ 15)   }
  'then'   { PT _ (TS _ 16)   }
  'true'   { PT _ (TS _ 17)   }
  L_Ident  { PT _ (TV $$)     }
  L_doubl  { PT _ (TD $$)     }
  L_Conj   { PT _ (T_Conj $$) }
  L_Disj   { PT _ (T_Disj $$) }
  L_TNot   { PT _ (T_TNot $$) }
  L_TEq    { PT _ (T_TEq $$)  }
  L_TNeq   { PT _ (T_TNeq $$) }
  L_TLeq   { PT _ (T_TLeq $$) }
  L_TGeq   { PT _ (T_TGeq $$) }

%%

Ident :: { Syntax.Grammar.Abs.Ident }
Ident  : L_Ident { Syntax.Grammar.Abs.Ident $1 }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Conj :: { Syntax.Grammar.Abs.Conj }
Conj  : L_Conj { Syntax.Grammar.Abs.Conj $1 }

Disj :: { Syntax.Grammar.Abs.Disj }
Disj  : L_Disj { Syntax.Grammar.Abs.Disj $1 }

TNot :: { Syntax.Grammar.Abs.TNot }
TNot  : L_TNot { Syntax.Grammar.Abs.TNot $1 }

TEq :: { Syntax.Grammar.Abs.TEq }
TEq  : L_TEq { Syntax.Grammar.Abs.TEq $1 }

TNeq :: { Syntax.Grammar.Abs.TNeq }
TNeq  : L_TNeq { Syntax.Grammar.Abs.TNeq $1 }

TLeq :: { Syntax.Grammar.Abs.TLeq }
TLeq  : L_TLeq { Syntax.Grammar.Abs.TLeq $1 }

TGeq :: { Syntax.Grammar.Abs.TGeq }
TGeq  : L_TGeq { Syntax.Grammar.Abs.TGeq $1 }

BConst :: { Syntax.Grammar.Abs.BConst }
BConst
  : 'true' { Syntax.Grammar.Abs.BTrue }
  | 'false' { Syntax.Grammar.Abs.BFalse }

Exp8 :: { Syntax.Grammar.Abs.Exp }
Exp8
  : Ident { Syntax.Grammar.Abs.Var $1 }
  | Double { Syntax.Grammar.Abs.DVal $1 }
  | BConst { Syntax.Grammar.Abs.BVal $1 }
  | 'rand' { Syntax.Grammar.Abs.Rand }

Exp7 :: { Syntax.Grammar.Abs.Exp }
Exp7
  : '-' Exp8 { Syntax.Grammar.Abs.Min $2 }
  | Exp7 '^' Exp8 { Syntax.Grammar.Abs.Pow $1 $3 }

Exp6 :: { Syntax.Grammar.Abs.Exp }
Exp6
  : Exp6 '*' Exp7 { Syntax.Grammar.Abs.Mul $1 $3 }
  | Exp6 '/' Exp7 { Syntax.Grammar.Abs.Div $1 $3 }
  | Exp6 '%' Exp7 { Syntax.Grammar.Abs.Mod $1 $3 }

Exp5 :: { Syntax.Grammar.Abs.Exp }
Exp5
  : Exp5 '+' Exp6 { Syntax.Grammar.Abs.Add $1 $3 }
  | Exp5 '-' Exp6 { Syntax.Grammar.Abs.Sub $1 $3 }

Exp4 :: { Syntax.Grammar.Abs.Exp }
Exp4
  : Exp4 TEq Exp5 { Syntax.Grammar.Abs.Eq $1 $2 $3 }
  | Exp4 '<' Exp5 { Syntax.Grammar.Abs.Lt $1 $3 }
  | Exp4 '>' Exp5 { Syntax.Grammar.Abs.Gt $1 $3 }
  | Exp4 TNeq Exp5 { Syntax.Grammar.Abs.Neq $1 $2 $3 }
  | Exp4 TLeq Exp5 { Syntax.Grammar.Abs.Leq $1 $2 $3 }
  | Exp4 TGeq Exp5 { Syntax.Grammar.Abs.Geq $1 $2 $3 }

Exp3 :: { Syntax.Grammar.Abs.Exp }
Exp3 : TNot Exp4 { Syntax.Grammar.Abs.Not $1 $2 }

Exp2 :: { Syntax.Grammar.Abs.Exp }
Exp2
  : Exp2 Conj Exp3 { Syntax.Grammar.Abs.And $1 $2 $3 }
  | Exp2 Disj Exp3 { Syntax.Grammar.Abs.Or $1 $2 $3 }

Exp1 :: { Syntax.Grammar.Abs.Exp }
Exp1
  : 'if' Exp2 'then' Exp2 'else' Exp2 { Syntax.Grammar.Abs.Ite $2 $4 $6 }

Exp :: { Syntax.Grammar.Abs.Exp }
Exp
  : '(' Exp ',' Exp ',' Exp ')' { Syntax.Grammar.Abs.Triple $2 $4 $6 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

