-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Syntax.Grammar.Par
  ( happyError
  , myLexer
  , pTrip
  ) where

import Prelude

import qualified Syntax.Grammar.Abs
import Syntax.Grammar.Lex

}

%name pTrip Trip
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'      { PT _ (TS _ 1)  }
  '!='     { PT _ (TS _ 2)  }
  '%'      { PT _ (TS _ 3)  }
  '('      { PT _ (TS _ 4)  }
  ')'      { PT _ (TS _ 5)  }
  '*'      { PT _ (TS _ 6)  }
  '+'      { PT _ (TS _ 7)  }
  '-'      { PT _ (TS _ 8)  }
  '/'      { PT _ (TS _ 9)  }
  ';'      { PT _ (TS _ 10) }
  '<'      { PT _ (TS _ 11) }
  '<='     { PT _ (TS _ 12) }
  '=='     { PT _ (TS _ 13) }
  '>'      { PT _ (TS _ 14) }
  '>='     { PT _ (TS _ 15) }
  'and'    { PT _ (TS _ 16) }
  'cos'    { PT _ (TS _ 17) }
  'else'   { PT _ (TS _ 18) }
  'exp'    { PT _ (TS _ 19) }
  'if'     { PT _ (TS _ 20) }
  'or'     { PT _ (TS _ 21) }
  'rand()' { PT _ (TS _ 22) }
  'sin'    { PT _ (TS _ 23) }
  'sqrt'   { PT _ (TS _ 24) }
  'then'   { PT _ (TS _ 25) }
  'x'      { PT _ (TS _ 26) }
  'y'      { PT _ (TS _ 27) }
  '{'      { PT _ (TS _ 28) }
  '}'      { PT _ (TS _ 29) }
  L_doubl  { PT _ (TD $$)   }

%%

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Exp :: { Syntax.Grammar.Abs.Exp }
Exp
  : Exp1 { $1 }
  | 'if' '(' BExp ')' 'then' Exp1 'else' Exp1 { Syntax.Grammar.Abs.Ite $3 $6 $8 }

Exp1 :: { Syntax.Grammar.Abs.Exp }
Exp1
  : Exp2 { $1 }
  | Exp1 '+' Exp2 { Syntax.Grammar.Abs.Add $1 $3 }
  | Exp1 '-' Exp2 { Syntax.Grammar.Abs.Sub $1 $3 }

Exp2 :: { Syntax.Grammar.Abs.Exp }
Exp2
  : Exp3 { $1 }
  | Exp2 '*' Exp3 { Syntax.Grammar.Abs.Mul $1 $3 }
  | Exp2 '/' Exp3 { Syntax.Grammar.Abs.Div $1 $3 }
  | Exp2 '%' Exp3 { Syntax.Grammar.Abs.Mod $1 $3 }

Exp3 :: { Syntax.Grammar.Abs.Exp }
Exp3 : Exp4 { $1 }

Exp4 :: { Syntax.Grammar.Abs.Exp }
Exp4
  : Exp5 { $1 }
  | '-' Exp5 { Syntax.Grammar.Abs.Min $2 }
  | 'sqrt' '(' Exp5 ')' { Syntax.Grammar.Abs.Sqrt $3 }
  | 'sin' '(' Exp5 ')' { Syntax.Grammar.Abs.Sin $3 }
  | 'cos' '(' Exp5 ')' { Syntax.Grammar.Abs.Cos $3 }
  | 'exp' '(' Exp5 ')' { Syntax.Grammar.Abs.EPow $3 }

Exp5 :: { Syntax.Grammar.Abs.Exp }
Exp5
  : '(' Exp ')' { $2 }
  | Var { Syntax.Grammar.Abs.EVar $1 }
  | DVal { Syntax.Grammar.Abs.EDVal $1 }
  | 'rand()' { Syntax.Grammar.Abs.Rand }

BExp :: { Syntax.Grammar.Abs.BExp }
BExp
  : BExp1 { $1 } | BExp 'or' BExp1 { Syntax.Grammar.Abs.Or $1 $3 }

BExp1 :: { Syntax.Grammar.Abs.BExp }
BExp1
  : BExp2 { $1 } | BExp1 'and' BExp2 { Syntax.Grammar.Abs.And $1 $3 }

BExp2 :: { Syntax.Grammar.Abs.BExp }
BExp2 : BExp3 { $1 } | '!' BExp3 { Syntax.Grammar.Abs.Not $2 }

BExp3 :: { Syntax.Grammar.Abs.BExp }
BExp3
  : '(' BExp ')' { $2 }
  | Exp '==' Exp { Syntax.Grammar.Abs.Eq $1 $3 }
  | Exp '<' Exp { Syntax.Grammar.Abs.Lt $1 $3 }
  | Exp '>' Exp { Syntax.Grammar.Abs.Gt $1 $3 }
  | Exp '!=' Exp { Syntax.Grammar.Abs.Neq $1 $3 }
  | Exp '<=' Exp { Syntax.Grammar.Abs.Leq $1 $3 }
  | Exp '>=' Exp { Syntax.Grammar.Abs.Geq $1 $3 }

Var :: { Syntax.Grammar.Abs.Var }
Var
  : 'x' { Syntax.Grammar.Abs.XVar } | 'y' { Syntax.Grammar.Abs.YVar }

DVal :: { Syntax.Grammar.Abs.DVal }
DVal : Double { Syntax.Grammar.Abs.Val $1 }

Trip :: { Syntax.Grammar.Abs.Trip }
Trip
  : '{' Exp ';' Exp ';' Exp '}' { Syntax.Grammar.Abs.Triple $2 $4 $6 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

