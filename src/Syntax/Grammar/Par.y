-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Syntax.Grammar.Par
  ( happyError
  , myLexer
  , pExp
  , pType
  ) where

import Prelude

import qualified Syntax.Grammar.Abs
import Syntax.Grammar.Lex

}

%name pExp Exp
%name pType Type
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'      { PT _ (TS _ 1)  }
  '!='     { PT _ (TS _ 2)  }
  '%'      { PT _ (TS _ 3)  }
  '('      { PT _ (TS _ 4)  }
  ')'      { PT _ (TS _ 5)  }
  '*'      { PT _ (TS _ 6)  }
  '+'      { PT _ (TS _ 7)  }
  ','      { PT _ (TS _ 8)  }
  '-'      { PT _ (TS _ 9)  }
  '->'     { PT _ (TS _ 10) }
  '/'      { PT _ (TS _ 11) }
  ';'      { PT _ (TS _ 12) }
  '<'      { PT _ (TS _ 13) }
  '<='     { PT _ (TS _ 14) }
  '=='     { PT _ (TS _ 15) }
  '>'      { PT _ (TS _ 16) }
  '>='     { PT _ (TS _ 17) }
  'Bool'   { PT _ (TS _ 18) }
  'Double' { PT _ (TS _ 19) }
  'L'      { PT _ (TS _ 20) }
  'R'      { PT _ (TS _ 21) }
  '['      { PT _ (TS _ 22) }
  ']'      { PT _ (TS _ 23) }
  'and'    { PT _ (TS _ 24) }
  'cos'    { PT _ (TS _ 25) }
  'else'   { PT _ (TS _ 26) }
  'exp'    { PT _ (TS _ 27) }
  'fst'    { PT _ (TS _ 28) }
  'if'     { PT _ (TS _ 29) }
  'lambda' { PT _ (TS _ 30) }
  'left'   { PT _ (TS _ 31) }
  'match'  { PT _ (TS _ 32) }
  'or'     { PT _ (TS _ 33) }
  'rand()' { PT _ (TS _ 34) }
  'right'  { PT _ (TS _ 35) }
  'sin'    { PT _ (TS _ 36) }
  'snd'    { PT _ (TS _ 37) }
  'sqrt'   { PT _ (TS _ 38) }
  'then'   { PT _ (TS _ 39) }
  '{'      { PT _ (TS _ 40) }
  '}'      { PT _ (TS _ 41) }
  L_Ident  { PT _ (TV $$)   }
  L_doubl  { PT _ (TD $$)   }

%%

Ident :: { Syntax.Grammar.Abs.Ident }
Ident  : L_Ident { Syntax.Grammar.Abs.Ident $1 }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Exp :: { Syntax.Grammar.Abs.Exp }
Exp
  : Exp1 { $1 }
  | 'if' '(' Exp ')' 'then' Exp1 'else' Exp1 { Syntax.Grammar.Abs.Ite $3 $6 $8 }
  | 'match' Exp '{' 'L' Ident '->' Exp ';' 'R' Ident '->' Exp '}' { Syntax.Grammar.Abs.Match $2 $5 $7 $10 $12 }
  | '(' Exp ',' Exp ')' { Syntax.Grammar.Abs.Tup $2 $4 }
  | 'lambda' Ident '->' Exp { Syntax.Grammar.Abs.Abstr $2 $4 }

Exp1 :: { Syntax.Grammar.Abs.Exp }
Exp1 : Exp2 { $1 }

Exp2 :: { Syntax.Grammar.Abs.Exp }
Exp2
  : Exp3 { $1 }
  | Exp2 'and' Exp3 { Syntax.Grammar.Abs.And $1 $3 }
  | Exp2 'or' Exp3 { Syntax.Grammar.Abs.Or $1 $3 }

Exp3 :: { Syntax.Grammar.Abs.Exp }
Exp3 : Exp4 { $1 } | '!' Exp4 { Syntax.Grammar.Abs.Not $2 }

Exp4 :: { Syntax.Grammar.Abs.Exp }
Exp4
  : Exp5 { $1 }
  | Exp4 '==' Exp5 { Syntax.Grammar.Abs.Eq $1 $3 }
  | Exp4 '<' Exp5 { Syntax.Grammar.Abs.Lt $1 $3 }
  | Exp4 '>' Exp5 { Syntax.Grammar.Abs.Gt $1 $3 }
  | Exp4 '!=' Exp5 { Syntax.Grammar.Abs.Neq $1 $3 }
  | Exp4 '<=' Exp5 { Syntax.Grammar.Abs.Leq $1 $3 }
  | Exp4 '>=' Exp5 { Syntax.Grammar.Abs.Geq $1 $3 }

Exp5 :: { Syntax.Grammar.Abs.Exp }
Exp5
  : Exp6 { $1 }
  | Exp5 '+' Exp6 { Syntax.Grammar.Abs.Add $1 $3 }
  | Exp5 '-' Exp6 { Syntax.Grammar.Abs.Sub $1 $3 }

Exp6 :: { Syntax.Grammar.Abs.Exp }
Exp6
  : Exp7 { $1 }
  | Exp6 '*' Exp7 { Syntax.Grammar.Abs.Mul $1 $3 }
  | Exp6 '/' Exp7 { Syntax.Grammar.Abs.Div $1 $3 }
  | Exp6 '%' Exp7 { Syntax.Grammar.Abs.Mod $1 $3 }

Exp7 :: { Syntax.Grammar.Abs.Exp }
Exp7 : Exp8 { $1 }

Exp8 :: { Syntax.Grammar.Abs.Exp }
Exp8
  : Exp9 { $1 }
  | '-' Exp9 { Syntax.Grammar.Abs.Min $2 }
  | 'sqrt' '(' Exp9 ')' { Syntax.Grammar.Abs.Sqrt $3 }
  | 'sin' '(' Exp9 ')' { Syntax.Grammar.Abs.Sin $3 }
  | 'cos' '(' Exp9 ')' { Syntax.Grammar.Abs.Cos $3 }
  | 'exp' '(' Exp9 ')' { Syntax.Grammar.Abs.EPow $3 }

Exp9 :: { Syntax.Grammar.Abs.Exp }
Exp9
  : Exp10 { $1 }
  | 'left' Exp10 { Syntax.Grammar.Abs.InL $2 }
  | 'right' Exp10 { Syntax.Grammar.Abs.InR $2 }
  | 'fst' Exp10 { Syntax.Grammar.Abs.Fst $2 }
  | 'snd' Exp10 { Syntax.Grammar.Abs.Snd $2 }

Exp10 :: { Syntax.Grammar.Abs.Exp }
Exp10
  : '(' Exp ')' { $2 }
  | Ident { Syntax.Grammar.Abs.Var $1 }
  | DVal { Syntax.Grammar.Abs.EDVal $1 }
  | 'rand()' { Syntax.Grammar.Abs.Rand }
  | Exp10 Exp10 { Syntax.Grammar.Abs.App $1 $2 }

Type :: { Syntax.Grammar.Abs.Type }
Type
  : Type1 { $1 }
  | Type '->' Type { Syntax.Grammar.Abs.TFun $1 $3 }
  | '(' Type ',' Type ')' { Syntax.Grammar.Abs.TProd $2 $4 }
  | '[' Type '+' Type ']' { Syntax.Grammar.Abs.TCoprod $2 $4 }

Type1 :: { Syntax.Grammar.Abs.Type }
Type1
  : Type2 { $1 }
  | 'Double' { Syntax.Grammar.Abs.TDouble }
  | 'Bool' { Syntax.Grammar.Abs.TBool }

Type2 :: { Syntax.Grammar.Abs.Type }
Type2 : '(' Type ')' { $2 }

DVal :: { Syntax.Grammar.Abs.DVal }
DVal : Double { Syntax.Grammar.Abs.Val $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

